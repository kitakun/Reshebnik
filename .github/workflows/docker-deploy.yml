name: Docker Build and Deploy

on:
  push:
    branches: [ master ]
  workflow_dispatch:

env:
  CONTAINER_NAME: tabli-container
  IMAGE_NAME: tabli
  PORT: 443

jobs:
  build-and-deploy:
    runs-on: self-hosted
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      
    - name: Copy certificate
      run: cp /home/b.tabligo.ru.pfx ./certificate.pfx
      
    - name: Create appsettings.Production.json from secrets
      env:
        CONNECTION_STRING: ${{ secrets.CONNECTION_STRING }}
        JWT_SECRET_KEY: ${{ secrets.JWT_SECRET_KEY }}
        CLICKHOUSE_PASSWORD: ${{ secrets.CLICKHOUSE_PASSWORD }}
        EMAIL_PASSWORD: ${{ secrets.EMAIL_PASSWORD }}
        GPT_API_KEY: ${{ secrets.GPT_API_KEY || 'your-openai-api-key-here' }}
        PROXY_URL: ${{ secrets.PROXY_URL || 'null' }}
        PROXY_TYPE: ${{ secrets.PROXY_TYPE || 'Http' }}
        PROXY_USERNAME: ${{ secrets.PROXY_USERNAME || 'null' }}
        PROXY_PASSWORD: ${{ secrets.PROXY_PASSWORD || 'null' }}
        USE_ALLOWLIST: ${{ secrets.USE_ALLOWLIST || 'true' }}
        PROXY_ALLOWLIST: ${{ secrets.PROXY_ALLOWLIST || '["api.openai.com", "*.openai.com"]' }}
      run: |
        # Create the JSON file using printf to avoid shell expansion issues
        printf '{
          "Logging": {
            "LogLevel": {
              "Default": "Information",
              "Microsoft.AspNetCore": "Warning"
            }
          },
          "AllowedHosts": "*",
          "ConnectionStrings": {
            "DefaultConnection": "%s"
          },
          "Jwt": {
            "Key": "%s",
            "Issuer": "tabli.go new.tabli.go tabli.su tabli.ru tabli.rf tabli.com gogogo"
          },
          "Clickhouse": {
            "prefix": "prod",
            "host": "147.45.254.159",
            "port": "8123",
            "username": "gen_user",
            "password": "%s",
            "dbName": "default_db"
          },
          "Email": {
            "login": "noreply@tabligo.ru",
            "password": "%s",
            "onetimepass": "%s",
            "name": "Tabligo"
          },
          "Gpt": {
            "ApiKey": "%s",
            "BaseUrl": "https://api.openai.com/v1",
            "ProxyUrl": "%s",
            "ProxyType": "%s",
            "ProxyUsername": "%s",
            "ProxyPassword": "%s",
            "ProxyBypassOnLocal": true,
            "UseAllowList": %s,
            "ProxyAllowList": %s
          }
        }' "$CONNECTION_STRING" "$JWT_SECRET_KEY" "$CLICKHOUSE_PASSWORD" "$EMAIL_PASSWORD" "$EMAIL_PASSWORD" "$GPT_API_KEY" "$PROXY_URL" "$PROXY_TYPE" "$PROXY_USERNAME" "$PROXY_PASSWORD" "$USE_ALLOWLIST" "$PROXY_ALLOWLIST" > appsettings.Production.json
        
        # Validate the JSON file
        python3 -m json.tool appsettings.Production.json > /dev/null
        echo "‚úÖ appsettings.Production.json created and validated successfully"
        
        # Show the first few lines for debugging (without sensitive data)
        echo "üìÑ Generated appsettings.Production.json structure:"
        head -20 appsettings.Production.json
        
        # Verify the file exists and has content
        if [ ! -s appsettings.Production.json ]; then
          echo "‚ùå appsettings.Production.json is empty or missing!"
          exit 1
        fi
        
        echo "‚úÖ appsettings.Production.json is ready for Docker build"
      
    - name: Build Docker image
      run: docker build --build-arg DATETIME_NOW=$(date -u +"%Y-%m-%dT%H:%M:%SZ") --build-arg CONNECTION_STRING="${{ secrets.CONNECTION_STRING }}" --build-arg JWT_SECRET_KEY="${{ secrets.JWT_SECRET_KEY }}" --build-arg CLICKHOUSE_PASSWORD="${{ secrets.CLICKHOUSE_PASSWORD }}" --build-arg EMAIL_PASSWORD="${{ secrets.EMAIL_PASSWORD }}" -t ${{ env.IMAGE_NAME }} .
      
    - name: Stop existing container
      run: |
        if docker ps -q -f name=${{ env.CONTAINER_NAME }} | grep -q .; then
          echo "Stopping existing container..."
          docker stop ${{ env.CONTAINER_NAME }}
        else
          echo "No running container found with name ${{ env.CONTAINER_NAME }}"
        fi
        
    - name: Remove existing container
      run: |
        if docker ps -aq -f name=${{ env.CONTAINER_NAME }} | grep -q .; then
          echo "Removing existing container..."
          docker rm ${{ env.CONTAINER_NAME }}
        else
          echo "No container found with name ${{ env.CONTAINER_NAME }}"
        fi
        
    - name: Run new container
      run: |
        docker run -d \
          --restart=always \
          --name ${{ env.CONTAINER_NAME }} \
          -p ${{ env.PORT }}:${{ env.PORT }} \
          ${{ env.IMAGE_NAME }}
          
    - name: Verify container is running
      run: |
        echo "Waiting for container to start..."
        sleep 10
        
        echo "Checking container status..."
        if docker ps | grep -q ${{ env.CONTAINER_NAME }}; then
          echo "‚úÖ Container is running successfully!"
          docker ps | grep ${{ env.CONTAINER_NAME }}
        else
          echo "‚ùå Container failed to start!"
          docker ps -a | grep ${{ env.CONTAINER_NAME }}
          exit 1
        fi
        
    - name: Show container logs
      if: always()
      run: |
        echo "Container logs (last 50 lines):"
        docker logs ${{ env.CONTAINER_NAME }} --tail 50 || echo "No logs available"
        
        echo "Container status:"
        docker ps -a | grep ${{ env.CONTAINER_NAME }} || echo "Container not found"
